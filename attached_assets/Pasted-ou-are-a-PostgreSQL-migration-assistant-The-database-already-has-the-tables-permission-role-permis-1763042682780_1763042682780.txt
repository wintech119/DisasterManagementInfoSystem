ou are a PostgreSQL migration assistant.
The database already has the tables permission, role_permission, and user_role.
Do NOT drop any existing tables or data.
Your task is to generate and run a safe, idempotent SQL migration that updates these existing tables so they match the following target structure (including columns, NOT NULL constraints, defaults, primary keys, unique constraints, foreign keys, and helpful indexes):
BEGIN;

------------------------------------------------------------
-- 1. PERMISSION TABLE
------------------------------------------------------------
-- Add / align columns
ALTER TABLE permission
  ADD COLUMN IF NOT EXISTS perm_id      INTEGER GENERATED BY DEFAULT AS IDENTITY,
  ADD COLUMN IF NOT EXISTS resource     VARCHAR(40),
  ADD COLUMN IF NOT EXISTS action       VARCHAR(32),
  ADD COLUMN IF NOT EXISTS create_by_id VARCHAR(20) NOT NULL DEFAULT 'system',
  ADD COLUMN IF NOT EXISTS create_dtime TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS update_by_id VARCHAR(20) NOT NULL DEFAULT 'system',
  ADD COLUMN IF NOT EXISTS update_dtime TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS version_nbr  INTEGER NOT NULL DEFAULT 1;

-- Enforce NOT NULL on required fields (only if they exist)
ALTER TABLE permission
  ALTER COLUMN resource SET NOT NULL,
  ALTER COLUMN action   SET NOT NULL;

-- Primary Key on perm_id (if missing)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conrelid = 'permission'::regclass
      AND contype = 'p'
  ) THEN
    ALTER TABLE permission
      ADD CONSTRAINT pk_permission PRIMARY KEY (perm_id);
  END IF;
END$$;

-- Unique constraint on (resource, action)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'uq_permission_resource_action'
  ) THEN
    ALTER TABLE permission
      ADD CONSTRAINT uq_permission_resource_action UNIQUE (resource, action);
  END IF;
END$$;

------------------------------------------------------------
-- 2. ROLE_PERMISSION TABLE (ROLE → PERMISSION)
------------------------------------------------------------
-- Add / align columns
ALTER TABLE role_permission
  ADD COLUMN IF NOT EXISTS role_id      INTEGER,
  ADD COLUMN IF NOT EXISTS perm_id      INTEGER,
  ADD COLUMN IF NOT EXISTS scope_json   JSONB,
  ADD COLUMN IF NOT EXISTS create_by_id VARCHAR(20) NOT NULL DEFAULT 'system',
  ADD COLUMN IF NOT EXISTS create_dtime TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS update_by_id VARCHAR(20) NOT NULL DEFAULT 'system',
  ADD COLUMN IF NOT EXISTS update_dtime TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS version_nbr  INTEGER NOT NULL DEFAULT 1;

ALTER TABLE role_permission
  ALTER COLUMN role_id SET NOT NULL,
  ALTER COLUMN perm_id SET NOT NULL;

-- Primary Key (role_id, perm_id)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'pk_role_permission'
  ) THEN
    ALTER TABLE role_permission
      ADD CONSTRAINT pk_role_permission PRIMARY KEY (role_id, perm_id);
  END IF;
END$$;

-- FK to role(role_id)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'fk_role_permission_role'
  ) THEN
    ALTER TABLE role_permission
      ADD CONSTRAINT fk_role_permission_role
      FOREIGN KEY (role_id) REFERENCES role(role_id);
  END IF;
END$$;

-- FK to permission(perm_id)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'fk_role_permission_perm'
  ) THEN
    ALTER TABLE role_permission
      ADD CONSTRAINT fk_role_permission_perm
      FOREIGN KEY (perm_id) REFERENCES permission(perm_id);
  END IF;
END$$;

-- Helpful indexes for lookups
CREATE INDEX IF NOT EXISTS ix_role_permission_role_id ON role_permission(role_id);
CREATE INDEX IF NOT EXISTS ix_role_permission_perm_id ON role_permission(perm_id);

------------------------------------------------------------
-- 3. USER_ROLE TABLE (USER ↔ ROLE)
------------------------------------------------------------
-- Add / align columns
ALTER TABLE user_role
  ADD COLUMN IF NOT EXISTS user_id      INTEGER,
  ADD COLUMN IF NOT EXISTS role_id      INTEGER,
  ADD COLUMN IF NOT EXISTS create_by_id VARCHAR(20) NOT NULL DEFAULT 'system',
  ADD COLUMN IF NOT EXISTS create_dtime TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS update_by_id VARCHAR(20) NOT NULL DEFAULT 'system',
  ADD COLUMN IF NOT EXISTS update_dtime TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS version_nbr  INTEGER NOT NULL DEFAULT 1;

ALTER TABLE user_role
  ALTER COLUMN user_id SET NOT NULL,
  ALTER COLUMN role_id SET NOT NULL;

-- Primary Key (user_id, role_id)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'pk_user_role'
  ) THEN
    ALTER TABLE user_role
      ADD CONSTRAINT pk_user_role PRIMARY KEY (user_id, role_id);
  END IF;
END$$;

-- FK to public."user"(id)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'fk_user_role_user'
  ) THEN
    ALTER TABLE user_role
      ADD CONSTRAINT fk_user_role_user
      FOREIGN KEY (user_id) REFERENCES public."user"(id);
  END IF;
END$$;

-- FK to role(role_id)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'fk_user_role_role'
  ) THEN
    ALTER TABLE user_role
      ADD CONSTRAINT fk_user_role_role
      FOREIGN KEY (role_id) REFERENCES role(role_id);
  END IF;
END$$;

-- Helpful indexes
CREATE INDEX IF NOT EXISTS ix_user_role_user_id ON user_role(user_id);
CREATE INDEX IF NOT EXISTS ix_user_role_role_id ON user_role(role_id);

COMMIT;

Key requirements:


The script must be idempotent (safe to run multiple times).


It must not drop or truncate any data.


It should rely on existing tables and just bring them up to the target schema above.

