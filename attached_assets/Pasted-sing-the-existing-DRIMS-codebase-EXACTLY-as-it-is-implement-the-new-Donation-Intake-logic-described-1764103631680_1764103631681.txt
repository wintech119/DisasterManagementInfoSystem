sing the existing DRIMS codebase EXACTLY as it is, implement the new Donation Intake logic described in the document “New Donation Intake Story” at /mnt/data/New Donation Intake Story.docx.

IMPORTANT CONSTRAINTS:
- Do NOT change or break any existing:
  - UI layouts (screens, forms, components, styling)
  - Navigation (menus, routes, URLs, redirects, breadcrumbs)
  - Workflows and behaviours not explicitly mentioned in the story
  - Database schema (tables, columns, constraints, triggers, indexes)
  - Security fixes, CSP, auth/roles, or permission checks
- The existing “Donation Intake” screen(s), routes, and templates MUST be reused.
  - Implement all new logic INSIDE the current Donation Intake UI and navigation.
  - Do NOT create new pages or new menu entries for intake; just enhance the current ones.

FEATURE TO IMPLEMENT:
1. Implement Donation Intake Entry – WORKFLOW A (ENTRY)
   - Implement all business rules exactly as described in the “New Donation Intake Story”:
     • Roles: Intake Entry role creates/edits intake.
     • Pre-conditions: Only donations with donation.status_code = 'V' and with at least one GOODS donation_item are eligible; FUNDS are excluded.
     • Header behaviour:
       - Use existing Donation Intake UI to select donation and target warehouse/inventory.
       - Load donation context (donor, description, country, event) as read-only.
       - Create/Update dnintake keyed by (donation_id, inventory_id).
       - Enforce intake_date, comments_text, status_code, and all audit/versioning rules without changing the schema.
     • Items grid:
       - Use the existing intake items UI, but load only GOODS donation_item rows.
       - Implement quantity behaviour: defective_qty, expired_qty editable; usable_qty derived; total quantity from donation_item.item_qty; enforce defective + expired ≤ donated quantity.
       - Implement batch/expiry logic based on item.is_batched_flag and item.can_expire_flag.
       - Keep UOM and Unit Cost read-only, pulled from the existing schema as described.
       - Compute Extended Cost as Total Qty * Unit Cost (read-only).
     • Submit for Verification:
       - Use the existing buttons/controls on the Donation Intake UI (do not move or restyle them).
       - On submit, validate all rules; upsert dnintake and dnintake_item rows; set dnintake.status_code = 'C'; dnintake_item.status_code = 'P'.
       - Use a single atomic transaction; rollback on any error and show user-friendly messages in the current UI.

2. Implement Donation Intake Verification – WORKFLOW B (VERIFICATION)
   - Reuse the existing navigation and screens for verification:
     • Use the existing “Donation Intake” / “Intake Verification” view or list; do NOT create new pages.
     • List only dnintake rows that match the story (e.g., status_code = 'C' and donation.status_code = 'V').
   - When a verifier opens an intake:
     • Reuse the same intake header and items UI, but in Verification mode.
     • Allow editing of the fields specified in the story (e.g., defective_qty, expired_qty, batch_no, batch_date, expiry_date, comments).
     • Keep read-only fields read-only as described.
   - On “Verify Intake” (using the existing button or action area):
     • Re-validate all data using the same rules as Entry.
     • Compute deltas between old and new dnintake_item quantities.
     • Update dnintake to status_code = 'V' with correct verify_by_id/verify_dtime, update_by_id/update_dtime, and version_nbr (optimistic locking).
     • Update dnintake_item rows with final quantities and status_code = 'V'.
     • Update itembatch and inventory aggregates according to the story, using existing tables and constraints WITHOUT altering them.
     • All changes must be in a single transaction; rollback on any error and show a clear error in the existing UI.

GENERAL RULES:
- Use the current Flask routes, blueprints, templates, components, and styling.
- Only add or adjust backend and frontend logic as necessary to satisfy the story.
- Do not rename or remove any existing routes, view functions, or templates.
- Do not add, remove, or alter any database objects (tables, columns, indexes, constraints).
- Preserve all existing security and CSP headers.

In summary, wire WORKFLOW A (Entry) and WORKFLOW B (Verification) into the existing Donation I